<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络学习笔记]]></title>
    <url>%2F2021%2F01%2F19%2Fnetwork_note%2F</url>
    <content type="text"><![CDATA[网络学习笔记 本文为我查漏补缺的时候记下的笔记，不同部分的比重十分不同 网络由两台或者以上的设备互联组成。 1PC1 PC2 设备之间使用以太网传递数据。设备对以太网硬件下达指令，以太网硬件和驱动将数据封包为以太网帧，通过以太网发送出去，到达对端设备。 以太网同步信号以太网帧的起始部分由前同步码和帧开始定界符组成。后面便跟随着MAC帧 前同步码/前导 帧开始界定符 MAC帧 0xAA * 7 （7Byte） 0xAB （1Byte） &gt;=64Bytes 前同步码用于同步对端设备的时钟，属于数电部分的物理信号，开始界定符表示接下来的内容属于以太网帧。 帧间隙 （Inter Frame Gap, IFG）在连续的以太网连接中，使用前导来区分前一帧和后一帧。除此之外，每一个帧在发送的时候会相隔有一定的比特间隙，这个间隙称为帧间隙。留意帧间隙使用比特进行衡量。在10/100Mbps以太网中，帧间隙为96Bits（12Byte） 帧时隙 （Inter Frame Slot, IFS）帧时隙用于定义每个数据帧占用的最小时间长度。在10/100Mbps以太网中，帧时隙为512Bits（MAC帧最小长度，下文讲解）。若在512位Bits的时间内没有收到有效帧，则认为线路是空闲的，而小于512Bits的帧信号则被认为是残帧，会被丢弃。故连续有效帧的相互时隙需要位于96Bits-512Bits之间。 定义帧时隙是为了共享同一条线路，实现多设备共用线路，提高利用率，使用CSMA/CD或CSMA/CA（带冲突检测的载波侦听多路访问）实现空闲时刻接收来自其他设备的有效以太网帧。 CSMA指载波侦听多路访问协议。 基本概念 载波监听：接收介质上的信息，并加以解析，判断共享信道有没有节点正在传输信息 多路访问：多个装置可以同时读取、写入媒介 媒介状态：媒介有繁忙与空闲两种媒介占用状态，空闲指在512Bits单位时间内无有效帧传输，繁忙则是在侦测当下的前512Bits有有效帧传输。 帧碰撞/帧冲突：在媒介繁忙的时候传送帧，形成帧冲突。 协议为多路访问协议，部署了CSMA的硬件与非CSMA硬件无法互联通信，故所有节点都需要部署CSMA。 CSMA节点在发送帧之前先监听媒介是否空闲，如果媒介繁忙，则根据工作模式进行下一步操作。 协议包括三种工作模式。 1-persistentes CSMA 节点持续监听媒介，一旦发现媒介空闲，立刻发送帧。 0-persistentes CSMA 节点不持续监听媒介，而是每过一段时间监听一次媒介，只要媒介在监听的时候为空闲，便立刻发送帧。 p-persistentes CSMA 节点持续监听媒介。一旦信道空闲，节点以p的概率发送帧，若此时不发送数据，则等待一段时间后，再次进入监听，并以p的概率再次发送帧 CSMA/CD指带冲突检测的载波侦听多路访问，实现在半双工介质上，要求设备可以在传送帧的同时监听帧，以确定是否发生碰撞。 在节点发送帧前，需要持续监听媒介。 一旦发现媒介空闲，则立刻发送帧。 在发送帧的同时，节点持续监听媒介，探测是否有别的节点也在同时刻发送帧。 若发送帧的过程中没有检测到别的节点也在发送帧到同一媒介，则成功传输 若发送帧过程中检测到别的节点也在发送帧，则检测到冲突，执行以下操作 立刻停止帧发送 发送特定的干扰序列，用于加强冲突 进行回退（Backoff），随机等待一个时间，然后尝试重传帧 以太网设备之间建立连接的过程建立连接的时候协商传输速率和双工模式称为自协商。 双方以太网接口在链路设置为Up状态前发送FLP（快速连接脉冲）序列，协商信息封装在FLP中（下文描述FLPs的定义），同时会通过FLT获取时钟、数字序列信息，用于调制介质信号。当设备对FLP无法做出有效反应，仅返回NLP（普通连接脉冲）的话，它被视为一个10BASE-T兼容设备。 以上两种脉冲类型使用在双绞线上，而不能应用在光纤等媒体 NLPs：是周期为16ms，脉冲宽度为100ns（10M）、10ns（100M）的脉冲信号 FLPs：是连续的17-33个脉冲，用于传输16Bits（2Byte）的链接码以进行自动协商。码宽为125us，在125us中有脉冲为1，无脉冲为0。这组数据只能被硬件接口模块识别而不是以太网连接的有效数据。 FLPs的报文被称为基本页，包含以下信息 位元 Bit 含义 0-4 指定自协商数据帧的类型，对于IEEE802.3为10000 5 1为支持10base-T半双工 6 1为支持10base-T全双工 7 1为支持100base-TX半双工 8 1为支持100base-TX全双工 9 1为支持100base-T4 10 1为流控有效，0为流控无效，决定后续通信是否有PAUSE帧（下文解释） 11 支持全双工连接时的非对称暂停机制 12 扩展下一页信息页，仅用于千兆端口 13 远程故障指示 14 握手信号Ack，当收到三个连续的相同FLP后，此位置1 15 指示是否有下一页基本页信息。下一页信息用来传输在自协商过程中已连接节点的额外信息 关于PAUSE帧的说明转自华为云 PAUSE帧（流量控制） 为什么要有流量控制呢？现在的网络有10M和100M的以太，那么当10m以太和100m以太共存的时候，那就有可能会产生这种线路速率不匹配的情况，这个时候，当通过交换机一个端口的流量过大，超出了它的处理能力时，就会发生端口拥塞，拥塞的时候那么丢包、重传、时延等都会随之而来，流量控制的作用时防止在出现拥塞的情况下丢帧。这里的流量控制采用的是最常用的一种方式PAUSE帧。在半双工方式下，流量控制是通过后退压力（backpressure）技术实现的，模拟产生碰撞，使得信息源降低发送速度。在全双工方式下流控一般遵循IEEE 802.3X标准。采用一64字节的PAUSE的帧来控制，使用一个保留的组播地址：01-80-C2-00-00-01发送给正在发送的站，发送站接到该帧后，就会暂停或停止发送。这个地址的数据不会被网桥和交换机所转发，所以PAUSE帧不会产生附加信息量。PAUSE功能应用场合： 一对终端（简单的两点网络） 一个交换机和一个终端 交换机和交换机之间的链路 PAUSE功能的增加主要是为了防止瞬时流量的过载导致的缓冲区溢出而造成以太网帧的丢弃。 PAUSE功能不能解决下列问题： 稳定状态的网络拥塞 端到端流量控制 比简单停启更复杂的机制 MAC帧每个MAC帧以DMAC目的MAC地址和SMAC源MAC地址起始（共6+6Byte），然后是承载着数据链路层，最后以一个32位的冗余校验码（4Byte）进行结尾，验证数据是否出现损坏。以太网帧的协议标准有两种，分别是IEEE802.3和Ethernet_II。现在绝大多数的以太网帧都为Ethernet_II帧，故暂时只介绍Ethernet_II Ethernet_II DMAC 目的MAC地址 SMAC 源MAC地址 Type &gt;= 0x0600 Data 数据 FCS 冗余验证码 6Byte 6Byte 2Byte 46-1500Byte 4Byte 接收端的网卡MAC地址 发送端的网卡MAC地址 协议类型，Ethernet_II大于0x0600 有效载荷，是有效的传输层数据 用于检测该帧是否有出错 TCP/IP协议族TCP/IP协议族以IP协议的实现为基础，构建三层及以上的协议层级。 开个坑，有空把TCP/IP协议族全部过一遍 华为，FAQ-以太网自协商的详细过程，https://support.huawei.com/enterprise/en/knowledge/KB1000068108 维基百科，以太网络，https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91#CSMA/CD%E5%85%B1%E4%BA%AB%E4%BB%8B%E8%B4%A8%E4%BB%A5%E5%A4%AA%E7%BD%91 徐方鑫，802.11协议精读3：CSMA/CD与CSMA/CA，https://zhuanlan.zhihu.com/p/20731045 hai niu，02数据在网络中的传输，https://zhuanlan.zhihu.com/p/101336720 *weixin_38848977*，以太网自动协商原理，https://www.huaweicloud.com/articles/3b6e771cc602777cbea14821c0686555.html 维基百科，互联网协议套组，https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>隧道</tag>
        <tag>VPN</tag>
        <tag>网络</tag>
        <tag>以太网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GUE over V2ray - 基于V2ray的L2/L3VPN]]></title>
    <url>%2F2020%2F11%2F11%2FGUE-over-V2ray%2F</url>
    <content type="text"><![CDATA[在这篇文章我试着搭建了WG over V2ray，实际上效果也相当不错。唯独有一点不太好的是Wireguard有加密功能，而这篇文章下的Vless+WS TLS里面，TLS也实现了加密的功能。这样就会产生双重加密，不但没什么意义而且会增加每个数据包的运算负担。所以这段时间一直在寻找一种更加简洁的，能在L4层无加密包装L3/L2的原生、容易配置的隧道。 其实GUE、FOU、VXLAN都可以工作在L4上，这里挑选了自己比较用的习惯的GUE，用V2ray实现加密与隐蔽传输。相比于Wireguard，这几个原生的简单隧道协议都需要双端配置一个回传的地址，将数据包传回给对端。由于相比于Wireguard这个是纯粹的对等协议，所以需要使用V2ray进行反向代理，将客户机的端口在本机上暴露出来。 配置 终端 IP GUE端口 服务端 10.33.33.1/32 3334 客户端 10.33.33.2/32 3333 先配置V2ray。 服务端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 服务端&#123; &quot;reverse&quot;:&#123; &quot;portals&quot;:[ &#123; &quot;tag&quot;:&quot;portal&quot;, &quot;domain&quot;:&quot;private.cloud.com&quot; &#125; ] &#125;, &quot;inbounds&quot;: [ &#123; &quot;tag&quot;:&quot;external&quot;, &quot;port&quot;:3333, &quot;protocol&quot;:&quot;dokodemo-door&quot;, &quot;settings&quot;:&#123; &quot;address&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:3333, &quot;network&quot;:&quot;udp&quot; &#125; &#125;, &#123; &quot;listen&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: 14444, &quot;protocol&quot;: &quot;vless&quot;, &quot;settings&quot;: &#123; &quot;decryption&quot;: &quot;none&quot;, &quot;clients&quot;: [ &#123; &quot;id&quot;: &quot;uuid&quot; &#125; ] &#125;, &quot;streamSettings&quot;: &#123; &quot;network&quot;: &quot;ws&quot;, &quot;wsSettings&quot;: &#123; &quot;path&quot;: &quot;/path&quot; &#125; &#125; &#125; ], &quot;outbounds&quot;: [ &#123; &quot;protocol&quot;: &quot;freedom&quot;, &quot;settings&quot;: &#123;&#125; &#125; ], &quot;routing&quot;:&#123; &quot;rules&quot;:[ &#123; &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;external&quot;, ], &quot;outboundTag&quot;:&quot;portal&quot; &#125;, &#123; &quot;type&quot;:&quot;field&quot;, &quot;domain&quot;:[ &quot;full:private.cloud.com&quot; ], &quot;outboundTag&quot;:&quot;portal&quot; &#125; ] &#125;&#125;// 自行配置caddy和CDN将请求转发到V2ray服务器上 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 客户端&#123; &quot;reverse&quot;:&#123; &quot;bridges&quot;:[ &#123; &quot;tag&quot;:&quot;bridge&quot;, &quot;domain&quot;:&quot;private.cloud.com&quot; &#125; ] &#125;, &quot;inbounds&quot;: [ &#123; &quot;tag&quot;:&quot;gue&quot;, &quot;port&quot;:3334, &quot;protocol&quot;:&quot;dokodemo-door&quot;, &quot;settings&quot;:&#123; &quot;address&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:3334, &quot;network&quot;:&quot;udp&quot; &#125; &#125; ], &quot;outbounds&quot;: [ &#123; &quot;tag&quot;: &quot;cdn&quot;, &quot;protocol&quot;: &quot;vless&quot;, &quot;settings&quot;: &#123; &quot;vnext&quot;: [ &#123; &quot;address&quot;: &quot;cdnaddress&quot;, &quot;port&quot;: 443, &quot;users&quot;: [ &#123; &quot;encryption&quot;: &quot;none&quot;, &quot;id&quot;: &quot;uuid&quot;, &quot;email&quot;: &quot;t@t.tt&quot; &#125; ] &#125; ] &#125;, &quot;streamSettings&quot;: &#123; &quot;network&quot;: &quot;ws&quot;, &quot;security&quot;: &quot;tls&quot;, &quot;tlsSettings&quot;: &#123; &quot;allowInsecure&quot;: true, &quot;serverName&quot;: &quot;address&quot; &#125;, &quot;wsSettings&quot;: &#123; &quot;path&quot;: &quot;/path&quot;, &quot;headers&quot;: &#123; &quot;Host&quot;: &quot;address&quot; &#125; &#125; &#125; &#125;, &#123; &quot;protocol&quot;:&quot;freedom&quot;, &quot;settings&quot;:&#123; &#125;, &quot;tag&quot;:&quot;out&quot; &#125; ], &quot;routing&quot;:&#123; &quot;rules&quot;:[ &#123; &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;gue&quot; ], &quot;outboundTag&quot;:&quot;cdn&quot; &#125;, &#123; &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;bridge&quot; ], &quot;domain&quot;:[ &quot;full:private.cloud.com&quot; ], &quot;outboundTag&quot;:&quot;hkcdn&quot; &#125;, &#123; &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;bridge&quot; ], &quot;outboundTag&quot;:&quot;out&quot; &#125; ] &#125;&#125; 然后配置GUE GRE over GUE配置123456# 服务端ip fou add port 3334 gueip link add gueov2 type gretap remote 127.0.0.1 ttl 225 encap gue encap-sport auto encap-dport 3333 encap-csum encap-remcsumip link set gueov2 upip link set dev gueov2 mtu 1420ip address add 10.33.33.1/32 dev gueov2 123456# 客户端ip fou add port 3333 gueip link add gueov2 type gretap remote 127.0.0.1 ttl 225 encap gue encap-sport auto encap-dport 3334 encap-csum encap-remcsumip link set gueov2 upip link set dev gueov2 mtu 1420ip address add 10.33.33.2/32 dev gueov2 留意把MTU改成正常大小，默认的MTU是巨型帧，不一定能通过V2的WSS隧道]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>隧道</tag>
        <tag>V2ray</tag>
        <tag>GUE</tag>
        <tag>GRE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网、翻墙|仅需一台VPS，让宽带拥有公网固定IP、翻越GFW|软路由网关]]></title>
    <url>%2F2020%2F10%2F14%2F2020-10-14-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E3%80%81%E7%BF%BB%E5%A2%99%E4%BB%85%E9%9C%80%E4%B8%80%E5%8F%B0VPS%EF%BC%8C%E8%AE%A9%E5%AE%BD%E5%B8%A6%E6%8B%A5%E6%9C%89%E5%85%AC%E7%BD%91%E5%9B%BA%E5%AE%9AIP%E3%80%81%E7%BF%BB%E8%B6%8AGFW%E8%BD%AF%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3%2F</url>
    <content type="text"><![CDATA[本教程会介绍VPN技术，并提到VPN在翻越GFW时会遇到的一些问题，然后会提供一种更加安全的、跨越GFW组建VPN二层网络的思路 0. GFW能管控什么？GFW如何对网络进行管控？网络这是你的家庭网络架构，你的笔记本电脑会连接到你的无线路由器，通过防火墙后连接上互联网。 图片来源：Draw.io 你发送的每个对外访问的数据包都会发送到你的家庭网关，通过电信商提供的宽带服务接入互联网后，家庭网关会根据路由表，向路由表指示的网关询问IP地址是否可以到达。再上一层的网关也会执行同样的操作，直到最后访问到你需要访问的IP地址。 有时候，应用访问的是域名。设备在接收到访问域名的请求后会向DNS服务器查询域名的IP地址，然后才会进行上面一套流程。 假设你要访问Youtube，域名是youtube.com在不考虑防火墙的情况下，你的电脑会先向DNS询问youtube.com的IP地址（A记录）。 图片来源：GFW是如何阻止我们访问国外网站的？（https://www.youtube.com/watch?v=f6dFKFeFntw） DNS服务器会返回一个域名的IP地址，然后设备会根据这个IP地址，将数据包发送到网关，最后访问到目标IP地址。 图片来源：GFW是如何阻止我们访问国外网站的？（https://www.youtube.com/watch?v=f6dFKFeFntw） GFW如果说你在中国大陆地区，你接入的网络架构应该是这样的。 你的设备询问访问国内的IP地址，运营商的网关会根据路由表自动路由到不同的网关。若访问海外的地址，运营商会将你的数据包转发到GFW里面进行审查，数据包通过审查则继续转发到海外的网关，未通过审查的数据包会被丢弃、替换、攻击等。（维基百科：防火长城） 现阶段，GFW会对以下的内容，在技术层面上进行网络攻击。 内容 封禁原因 技术手段 被屏蔽的域名 网站不符合言论审查要求 DNS污染 被屏蔽的IP IP提供不符合言论审查要求的服务 TCP阻断重置、UDP严格限速、黑洞路由、端口封锁 明文关键词 关键词不符合言论审查要求 TCP阻断重置 VPN流量 防范个人/团体不遵守言论审查 TCP阻断重置、UDP严格限速、黑洞路由、端口封锁 现在近乎明确会被GFW阻断、屏蔽、封禁的，数据包直接标识自己是隧道数据包的VPN有以下几种。 PPTP、L2TP、OpenVPN over UDP 有机会被屏蔽、限速、黑洞的VPN有以下几种。 Wireguard、GRE、IPSec、IKEv2、SSTP、Anyconnect 有较大机会被封锁的传输层以上的代理协议有以下几种。 SSH、Socks、HTTP代理、ShadowsocksR、Tor 1. 现阶段什么翻墙方式较难被封锁现阶段较为隐蔽的VPN和代理协议，根据底层传输层特征，隐蔽性由高至低排列（仅代表笔者观点） 传输层特征 VPN或代理类型 Websocks-TLS/HTTPS VPN-WS、V2ray-WSS、Trojan-WSS、GOST-WSS、Shadowsocks with Obfs WSS、HTTPS TLS SSL VPN、V2ray-TLS、Trojan、GOST、Socks over TLS、Shadowsocks with Obfs TLS QUIC V2ray-QUIC、GOST-QUIC KCP V2ray-KCP、GOST-KCP 无特征协议 V2ray-Vmess、Shadowsocks P2P网络 I2P 隐蔽性与性能、安全性无关 当下资料显示，GFW对待HTTPS和SSL/TLS流量最为宽松。根据《2019年6月翻墙快报》，GFW对于基于无加密Socks代理与VPN较为敏感，而对于非HTTPS、WSS的流量会随机阻断。在去年6月敏感时间，V2ray搭建在基于HTTPS的Websocket TLS传输层上、或是别的代理协议通过HTTPS Tunnel进行传输，都不会被GFW过度干扰。而I2P由于自身坚挺的P2P技术，只要即时补种可以作为轻度使用的良好方案。在特殊情况下，WSS传输层会被限速，但还尚未被完全封锁。可以总结，基于HTTPS传输层的代理和VPN是现行使用公网翻墙的最佳方法。 后续更新 维基百科：防火长城，https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E，2020年10月13日读取。 GFW的封杀手段以及常见的翻墙手段，https://note.hzy.pw/1798.html，2020年10月13日读取。 《2019年6月翻墙快报》，2019年7月11日，https://medium.com/@programthink/2019%E5%B9%B46%E6%9C%88%E7%BF%BB%E5%A2%99%E5%BF%AB%E6%8A%A5-%E5%85%BC%E8%B0%88%E7%94%A8-i2p-%E7%AA%81%E7%A0%B4%E5%B0%81%E9%94%81-f460a86f154f，2020年10月14日读取。]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>翻墙</tag>
        <tag>代理</tag>
        <tag>隧道</tag>
        <tag>VPN</tag>
        <tag>组网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试玩TUN/TAP over GOST-WSS]]></title>
    <url>%2F2020%2F10%2F11%2FGOST_Startup%2F</url>
    <content type="text"><![CDATA[在上个星期我试着搭建了Wireguard over Vless-Websocket，稳定性虽然不错但是性能实在是太差了，实在是不适合放在性能比较低下的NAT VPS上做中转之类的操作。即便是树莓派4b，跑满100M带宽也需要吃掉超过100%的CPU。再加上V2ray的功能是专门为了一站式应用层穿透代理设计的，端口转发只是V2ray自带的一个额外的功能罢了，并不是他的核心功能。由于没有研究过V2ray的代码也无法判断在跑端口转发的时候会不会运行了一些与端口转发无关的代码占用资源，不过最近看到了v2ray/discussion里面的一则讨论，测试显示GOST的ws+tls速度比v2ray快了一倍有余。 本篇将尝试使用GOST直接搭建使用Websocket-TLS传输层隧道进行通讯的TAP VPN，实现穿隧与组网。为了理解本篇内容，读者最少需要了解基本的网络、路由原理，需要懂得基础的OSI模型。 实践这次使用一台内地的NAT VPS与日本NTT VPS进行测试，使用GOST创建TAP设备，底层传输层走Websocket-TLS协议，让协议可实现套CDN等操作。 先在服务端和客户端下载GOST，安装到/usr/local/bin里面 1curl https://github.com/ginuerzh/gost/releases/download/v2.11.1/gost-linux-amd64-2.11.1.gz | gzip -dc &gt; /usr/local/bin/gost &amp;&amp; chmod +x /usr/local/bin/gost 在服务端安装caddy 1wget https://git.io/vra5C -O - -o /dev/null|bash 在服务端配置Systemd 1234567891011121314cat &gt; gost.service &lt;&lt; EOF[Unit]Description=Gost ProxyAfter=network.targetWants=network.target[Service]Type=simpleExecStart=/usr/local/bin/gost -L tap://127.0.0.1:8421 -L relay+ws://user:pass@127.0.0.1:48101?path=/gostRestart=always[Install]WantedBy=multi-user.targetEOF 上面的user和pass修改一下，path的意思是路径。然后8421是TAP协议设备的端口，48101是relay+ws的端口。 配置Caddy。 1234567891011cat &gt; /etc/Caddyfile &lt;&lt; EOFserverdomain &#123; gzip tls example@mail.com log /var/log/caddy.log proxy /gost localhost:48101 &#123; websocket header_upstream -Origin &#125;&#125;EOF 启动Caddy和GOST。 1234caddy startsystemctl start gostsystemctl enable gost 配置网桥并将GOST的TAP设备桥接到网桥上。 1234ip link add taps_bridge type bridgeip link set taps_bridge upip address add 100.66.0.1/24 dev taps_bridgeip link set tap0 master taps_bridge 在客户端配置GOST的systemd。 1234567891011121314cat &gt; gost.service &lt;&lt; EOF[Unit]Description=Gost ProxyAfter=network.targetWants=network.target[Service]Type=simpleExecStart=/usr/local/bin/gost -L tap://:8421/127.0.0.1:8421?net=100.66.0.2/24 -F relay+wss://user:pass@serverdomain:443?path=/gostRestart=always[Install]WantedBy=multi-user.targetEOF 然后在客户端启动GOST服务。 12systemctl enable gostsystemctl start gost 到这一步应该已经将GOST的TAP over WSS搭建完成，若你想套CDN之类的可以自己操作看看。 性能测试上面搭建的是wss协议的GOST，下面会一并测试TAP设备在TLS、KCP、QUIC传输层协议上的表现。 香港HKT搭建的iperf3服务器，宿迁联通百兆宽带，性能如下。 协议 上传 下载 Direct 16.4Mbps 3.22Mbps TLS 14.9Mbps 6.87Mbps KCP 7.92Mbps 1.39Mbps QUIC 8.66Mbps 8.20Mbps Relay+MTLS 12.6Mbps 9.42Mbps Relay+KCP 13.1Mbps 11.6Mbps 实测下来性能还不如GRE over Wireguard over Vless-WSS，不知道纯中转性能如何，之后有机会再更新吧。]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>翻墙</tag>
        <tag>代理</tag>
        <tag>隧道</tag>
        <tag>VPN</tag>
        <tag>组网</tag>
        <tag>GOST</tag>
        <tag>游戏加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireguard over Vmess/Vless - 安全隐蔽且容易配置的VPN三层隧道]]></title>
    <url>%2F2020%2F09%2F27%2FWireguard-over-V2ray%2F</url>
    <content type="text"><![CDATA[老早就有这个想法了，由于v2ray只是一个四层代理，相比VPN三层代理不够透明，所以有用VPN的倾向。 但是VPN协议早已被GFW摸得清清楚楚，断流、QoS管控绝对不会手软。所以肯定需要一个隧道来对接VPN协议。 原因选用Wireguard单纯是因为Linux原生支持Wireguard，配置相比于别的VPN协议实在是方便太多而且性能相对最好，而且由于是三层协议，还可以在这上面再添加GRE套娃变成GRE over Wireguard over Vmess…. 但是无论是GFW对于Wireguard的识别，还是ISP对于udp流量的QoS管控限制，都让裸Wireguard变得难以使用。所以这里还需要一个隧道，让数据包表层看起来安稳一些，不会受到ISP的特别关照。 在穿墙隧道这一方面，现阶段做的比较完善，且最高能以应用层穿隧的协议，估计V2ray的Vmess/Vless协议算是做的最为完善和成熟的了。 其实也有想过用GOST进行穿隧，据说性能更好。但GOST的配置方式我不熟悉，配置总是不成功。有时间研究一下再码一篇。 原理先设定有两台机子，一台是Server，一台是Client。 Server的对外IP是10.100.0.1，Client的对外IP是10.100.0.2。 V2ray套件中有一个Dokodemo-door入站协议，可以监听任意端口进行转发，并且支持在V2ray中路由。 先在Server架设好V2ray服务端，为了演示方便先使用普通的Vmess TCP协议。 1234567891011121314151617181920212223// vmess TCP&#123; "inbounds": [ &#123; "port": 16823, // 服务器监听端口 "protocol": "vmess", // 主传入协议 "settings": &#123; "clients": [ &#123; "id": "b831381d-6324-4d53-ad4f-8cda48b30811", "alterId": 64 &#125; ] &#125; &#125; ], "outbounds": [ &#123; "protocol": "freedom", "settings": &#123;&#125; &#125; ]&#125; 然后在Server再架设一个Wireguard接口。 123456789[Interface]PrivateKey = 2GjqFPL8IXKs3fECd4/FO6M1XnLFw4N8uHSzT9i62mc=Address = 10.101.0.1/32ListenPort = 10000 #监听10000端口[Peer]PublicKey = EZ/WK+xSI5cIL3diRAI2K0LVWefMiky3a3MxYBaL5As=AllowedIPs = 10.101.0.2/32 在Client里面安装V2ray，配置基础的Outbounds和Dokodemo-door转发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; "inbounds": [ &#123; "tag":"wireguard", "port":10000, "protocol":"dokodemo-door", "settings":&#123; "address":"127.0.0.1", "port":10000, "network":"udp" &#125; &#125; ], "outbounds": [ &#123; "tag":"proxy", "protocol": "vmess", // 出口协议 "settings": &#123; "vnext": [ &#123; "address": "10.100.0.1", // 服务器地址 "port": 16823, // 服务器端口 "users": [ &#123; "id": "b831381d-6324-4d53-ad4f-8cda48b30811", "alterId": 64 &#125; ] &#125; ] &#125; &#125; ], "routing":&#123; "rules":[ &#123; "type":"field", "inboundTag":[ "wireguard" ], "outboundTag":"proxy" &#125; ] &#125;&#125; 这样配置后，Client本机的10000端口便映射到Server的10000端口。接下来配置Client的Wireguard接口 12345678[Interface]PrivateKey = wAuG/N59IEqdQT42rTi8bfTP00ygLQMe6Rjl85aSE1k=Address = 10.101.0.2/32[Peer]PublicKey = PpE7xyUVEXfccO3GrFUad36s8WG5frJQTNd499oceHI=AllowedIPs = 10.101.0.1/32Endpoint = 127.0.0.1:10000 配置完毕后，将Server和Client总共4个服务全部启动即可 实验用Hyper-V开两台Ubuntu做实验，搭建虚拟机的过程就不记录了。设置好ip为上面规划的ip，搭完之后安装Wireguard与V2ray。 12345sudo suapt updateapt install wireguard -ycurl https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh | bashcurl https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-dat-release.sh | bash 然后编辑文件，留意新版的v2ray配置文件路径是/usr/local/etc/v2ray/config.json，上面已经介绍过如何配置了，这里不再复述。 Wireguard over Vmess挂完之后安装个iperf测试一下速度吧。 123456# Serverapt install iperfiperf -s# Clientapt install iperfiperf -c 10.101.0.1 实验测试结果iperf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# Direct------------------------------------------------------------Server listening on TCP port 5001TCP window size: 128 KByte (default)------------------------------------------------------------[ 4] local 10.100.0.1 port 5001 connected with 10.100.0.2 port 53168[ ID] Interval Transfer Bandwidth[ 4] 0.0-10.0 sec 22.2 GBytes 19.0 Gbits/sec# Wireguard only------------------------------------------------------------Server listening on TCP port 5001TCP window size: 128 KByte (default)------------------------------------------------------------[ 4] local 10.101.0.1 port 5001 connected with 10.101.0.2 port 55878[ ID] Interval Transfer Bandwidth[ 4] 0.0-10.0 sec 2.33 GBytes 1.99 Gbits/sec# Wireguard over Vmess-TCP------------------------------------------------------------Server listening on TCP port 5001TCP window size: 128 KByte (default)------------------------------------------------------------[ 4] local 10.101.0.1 port 5001 connected with 10.101.0.2 port 55868[ ID] Interval Transfer Bandwidth[ 4] 0.0-10.0 sec 177 MBytes 148 Mbits/sec# Wireguard over Vmess-WebSocket------------------------------------------------------------Server listening on TCP port 5001TCP window size: 128 KByte (default)------------------------------------------------------------[ 4] local 10.101.0.1 port 5001 connected with 10.101.0.2 port 56038[ ID] Interval Transfer Bandwidth[ 4] 0.0-10.0 sec 147 MBytes 123 Mbits/sec# Wireguard over Vmess-WebSocket-TLS------------------------------------------------------------Server listening on TCP port 5001TCP window size: 128 KByte (default)------------------------------------------------------------[ 4] local 10.101.0.1 port 5001 connected with 10.101.0.2 port 56338[ ID] Interval Transfer Bandwidth[ 4] 0.0-10.0 sec 138 MBytes 116 Mbits/sec# Wireguard over Vless-only------------------------------------------------------------Client connecting to 10.101.0.1, TCP port 5001TCP window size: 45.0 KByte (default)------------------------------------------------------------[ 3] local 10.101.0.2 port 56032 connected with 10.101.0.1 port 5001[ ID] Interval Transfer Bandwidth[ 3] 0.0-10.1 sec 122 KBytes 98.5 Kbits/sec# Wireguard over Vless-WebSocket------------------------------------------------------------Server listening on TCP port 5001TCP window size: 128 KByte (default)------------------------------------------------------------[ 4] local 10.101.0.1 port 5001 connected with 10.101.0.2 port 56016[ ID] Interval Transfer Bandwidth[ 4] 0.0- 7.8 sec 256 KBytes 268 Kbits/sec# Wireguard over Vless-WebSocket-TLS------------------------------------------------------------Client connecting to 10.101.0.1, TCP port 5001TCP window size: 45.0 KByte (default)------------------------------------------------------------[ 3] local 10.101.0.2 port 56330 connected with 10.101.0.1 port 5001[ ID] Interval Transfer Bandwidth[ 3] 0.0-10.0 sec 33.1 MBytes 27.7 Mbits/sec 协议 iperf速度 Direct 19.0 Gbits/sec Wireguard only 1.99 Gbits/sec Wireguard over Vmess-TCP 148 Mbits/sec Wireguard over Vmess-WebSocket 123 Mbits/sec Wireguard over Vmess-WebSocket-TLS 116 Mbits/sec Wireguard over Vless-Only 98.5 Kbits/sec Wireguard over Vless-WebSocket 268 Kbits/sec Wireguard over Vless-WebSocket-TLS 27.7 Mbits/sec 不知道为什么，一挂上Vless协议，iperf速度就急剧下降。正常使用没什么问题。 Ping123456789101112131415161718192021222324252627282930313233343536373839# Direct--- 10.100.0.1 ping statistics ---89 packets transmitted, 89 received, 0% packet loss, time 90096msrtt min/avg/max/mdev = 0.251/0.325/0.417/0.041 ms# Wireguard only--- 10.101.0.1 ping statistics ---86 packets transmitted, 86 received, 0% packet loss, time 87045msrtt min/avg/max/mdev = 0.348/0.471/0.664/0.061 ms# Wireguard over Vmess-TCP--- 10.101.0.1 ping statistics ---59 packets transmitted, 59 received, 0% packet loss, time 58303msrtt min/avg/max/mdev = 0.818/0.994/1.427/0.103 ms# Wireguard over Vmess-WebSocket--- 10.101.0.1 ping statistics ---57 packets transmitted, 57 received, 0% packet loss, time 56184msrtt min/avg/max/mdev = 0.875/1.092/4.503/0.464 ms# Wireguard over Vmess-WebSocket-TLS--- 10.101.0.1 ping statistics ---58 packets transmitted, 58 received, 0% packet loss, time 57295msrtt min/avg/max/mdev = 0.821/1.037/1.775/0.158 ms# Wireguard over Vless-Only--- 10.101.0.1 ping statistics ---58 packets transmitted, 50 received, 13.7931% packet loss, time 57710msrtt min/avg/max/mdev = 0.774/0.939/1.678/0.129 ms# Wireguard over Vless-WebSocket--- 10.101.0.1 ping statistics ---56 packets transmitted, 55 received, 1.78571% packet loss, time 55390msrtt min/avg/max/mdev = 0.734/0.963/1.339/0.100 ms# Wireguard over Vless-WebSocket-TLS--- 10.101.0.1 ping statistics ---58 packets transmitted, 58 received, 0% packet loss, time 57248msrtt min/avg/max/mdev = 0.830/1.024/1.252/0.090 ms 协议 延迟 Direct 0.325 ms Wireguard only 0.471 ms Wireguard over Vmess-TCP 0.994 ms Wireguard over Vmess-WebSocket 1.092 ms Wireguard over Vmess-WebSocket-TLS 1.037 ms Wireguard over Vless-Only 0.939 ms Wireguard over Vless-WebSocket 0.963 ms Wireguard over Vless-WebSocket-TLS 1.024 ms 可以见到环回的延迟表现均可以接受。需要注意的是，第一个包延迟最高可以达到50ms，这可能是因为Vmess、Vless和Wireguard都需要握手后才能进行通讯。 本机环回测试效果一般，接下来实装到香港HKT家宽线路，尝试连接稳定性和速度。 实装测试结果使用50M宽带与HKT千兆家宽测试 PING 协议 延迟 Direct 24.242 ms Wireguard only 38.591 ms Wireguard over Vmess-TCP 39.673 ms Wireguard over Vmess-WebSocket 39.762 ms Wireguard over Vmess-WebSocket-TLS 39.311 ms Wireguard over Vless-Only 39.579 ms Wireguard over Vless-WebSocket 39.865 ms Wireguard over Vless-WebSocket-TLS 34.411 ms Iperf测速 协议 iperf速度 Direct 6.24 Mbits/sec Wireguard only 3.64 Mbits/sec Wireguard over Vmess-TCP 3.32 Mbits/sec Wireguard over Vmess-WebSocket 2.75 Mbits/sec Wireguard over Vmess-WebSocket-TLS 2.39 Mbits/sec Wireguard over Vless-Only 556 Kbits/sec Wireguard over Vless-WebSocket 554 Kbits/sec Wireguard over Vless-WebSocket-TLS 560 Kbits/sec iperf怪怪的，有时间再做个speedtest测试吧 GRE over Wireguard over Vless-WebsocketSecurity-Web over Cloudflare CDN with Web这行字和咒语一样……但是如此组合的隧道不但可以实现极为稳定的代理功能，由于GRE是二层代理还能实现传输广播包，实现内网的互联互通，甚至可以设置策略让所有接入的节点根据目的IP走不同的出口。而且由于使用了Web作为外层的伪装，符合现在应对GFW主动探测的主流方案。 这里先不说明如何设置OSPF实现自动路由，只关注如何实现GRE over Wireguard over Vless-WebsocketSecurity over Cloudflare CDN with Web。 服务端Vless-WebsocketSecurity over Cloudflare CDN with Web由底层开始设置，先在Cloudflare里面把域名指向自己的VPS并且开启CDN代理，然后回到VPS里面安装V2ray与Caddy。上方原理说明已经描述如何安装V2ray 12345678910111213141516171819# 安装Caddywget -P /usr/local/bin &quot;https://daofa.cyou/c1/caddy.tar&quot; &amp;&amp; \tar -xvf /usr/local/bin/caddy.tar -C /usr/local/bin &amp;&amp; \rm /usr/local/bin/caddy.tar &amp;&amp; \chown root:root /usr/local/bin/caddy &amp;&amp; \chmod 755 /usr/local/bin/caddy &amp;&amp; \setcap &apos;cap_net_bind_service=+ep&apos; /usr/local/bin/caddy &amp;&amp; \mkdir /etc/caddy &amp;&amp; \mkdir /etc/ssl/caddy &amp;&amp; \chown -R root:root /etc/caddy &amp;&amp; \chown -R root:www-data /etc/ssl/caddy &amp;&amp; \chmod 770 /etc/ssl/caddy &amp;&amp; \touch /var/log/caddy.log &amp;&amp; \chown root:www-data /var/log/caddy.log &amp;&amp; \chmod 770 /var/log/caddy.log &amp;&amp; \mkdir -p /var/www/html &amp;&amp; \chown -R www-data:www-data /var/www &amp;&amp; \touch /etc/caddy/Caddyfile 配置V2ray服务端，与上方原理说明的配置文件相似，只是将Vmess改成了Vless然后添加了WS协议。 12345678910111213141516171819202122232425262728&#123; &quot;inbounds&quot;: [ &#123; &quot;port&quot;: 16823, // 服务器监听端口 &quot;protocol&quot;: &quot;vless&quot;, // 主传入协议 &quot;settings&quot;: &#123; &quot;decryption&quot;: &quot;none&quot;, &quot;clients&quot;: [ &#123; &quot;id&quot;: &quot;b831381d-6324-4d53-ad4f-8cda48b30811&quot; &#125; ] &#125;, &quot;streamSettings&quot;: &#123; &quot;network&quot;: &quot;ws&quot; &quot;wsSettings&quot;: &#123; &quot;path&quot;: &quot;/test&quot; &#125; &#125; &#125; ], &quot;outbounds&quot;: [ &#123; &quot;protocol&quot;: &quot;freedom&quot;, &quot;settings&quot;: &#123;&#125; &#125; ]&#125; 配置Caddy转发Websocket请求到V2ray 12345678910echo &quot;example.com &#123; \ root /var/www/html \ gzip \ tls example@mail.com \ log /var/log/caddy.log \ proxy /test localhost:16823 &#123; \ websocket \ header_upstream -Origin \ &#125; \&#125; &quot; &gt; /etc/caddy/Caddyfile 启动caddy和v2ray 1systemctl restart v2ray &amp;&amp; systemctl restart caddy 此时V2ray服务端搭建完毕。 Wireguard服务接口这个部分和上面原理说明的完全没有区别，直接按照上面的方法配置就可以了。 1234567891011121314# /etc/wireguard/wg0.conf-------------------------------[Interface]PrivateKey = 2GjqFPL8IXKs3fECd4/FO6M1XnLFw4N8uHSzT9i62mc=Address = 10.101.0.1/32ListenPort = 10000 #监听10000端口[Peer]PublicKey = EZ/WK+xSI5cIL3diRAI2K0LVWefMiky3a3MxYBaL5As=AllowedIPs = 10.101.0.2/32-------------------------------# 启动接口wg-quick up wg0 GRE接口在服务器上配置新的接口。 123456789101112# /etc/sysconfig/network-scripts/ifcfg-tun0-------------------------------DEVICE=tun0BOOTPROTO=noneONBOOT=noTYPE=GREPEER_OUTER_IPADDR=10.101.0.2 #对端IPPEER_INNER_IPADDR=10.101.1.2MY_INNER_IPADDR=10.101.1.1-------------------------------ifup tun0 此时所有的服务器端配置都设定完毕。 客户端V2ray接入1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#123; "inbounds": [ &#123; "tag":"wireguard", "port":10000, "protocol":"dokodemo-door", "settings":&#123; "address":"127.0.0.1", "port":10000, "network":"udp" &#125; &#125; ], "outbounds": [ &#123; "tag":"proxy", "protocol": "vless", // 出口协议 "settings": &#123; "vnext": [ &#123; "address": "example.com", // 服务器地址 "port": 443, "users": [ &#123; "encryption": "none", "id": "b831381d-6324-4d53-ad4f-8cda48b30811", &#125; ] &#125; ] &#125; "streamSettings": &#123; "network": "ws", "security": "tls", "tlsSettings": &#123; "allowInsecure": true, "serverName": "example.com" &#125;, "wsSettings": &#123; "path": "/test", "headers": &#123; "Host": "example.com" &#125; &#125; &#125; &#125; ], "routing":&#123; "rules":[ &#123; "type":"field", "inboundTag":[ "wireguard" ], "outboundTag":"proxy" &#125; ] &#125;&#125; Wireguard接入12345678[Interface]PrivateKey = wAuG/N59IEqdQT42rTi8bfTP00ygLQMe6Rjl85aSE1k=Address = 10.101.0.2/32[Peer]PublicKey = PpE7xyUVEXfccO3GrFUad36s8WG5frJQTNd499oceHI=AllowedIPs = 10.101.0.1/32Endpoint = 127.0.0.1:10000 然后输入wg-quick up wg0启动接口 GRE接入123456789101112# /etc/sysconfig/network-scripts/ifcfg-tun0-------------------------------DEVICE=tun0BOOTPROTO=noneONBOOT=noTYPE=GREPEER_OUTER_IPADDR=10.101.0.1 #对端IPPEER_INNER_IPADDR=10.101.1.1MY_INNER_IPADDR=10.101.1.2-------------------------------ifup tun0 最后在客户端输入ping 10.101.1.1，如果ping通了则算是打通了GRE隧道。]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>翻墙</tag>
        <tag>代理</tag>
        <tag>隧道</tag>
        <tag>Wireguard</tag>
        <tag>V2ray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雲筏科技 歐洲9元NAT-VPS Cloudflare純IPV6建站]]></title>
    <url>%2F2020%2F09%2F08%2F%E4%BA%91%E7%AD%8F%E7%A7%91%E6%8A%80%20%E6%AC%A7%E6%B4%B29%E5%85%83NAT-VPS%E8%AF%84%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[雲筏科技 歐洲9元NAT-VPS Cloudflare純IPV6建站雲筏科技最近改版了，之前用過他家的大盤雞，現在改版後反而下架了。但是出了個9元最低配的歐洲NAT主機，還有IPv6。 基本信息 E5 1650 v3 1 x Core 1G RAM 40G系統盤+10G數據盤 網絡30Mbps（測 試中為上載限速30M） 提供10個IPv4端口 1個IPv6地址 實際測試ifconfig中，有兩個IPv6，一個是128長度的，一個是64長度的。 NAT IPv4與兩個IPv6都位於德國 基本測試使用以下腳本跑了基本測試 1wget -qO- bench.sh | bash 測試結果 1234567891011121314151617181920212223242526272829303132333435---------------------------------------------------------------------- CPU Model : Intel(R) Xeon(R) CPU E5-1650 v3 @ 3.50GHz CPU Cores : 1 CPU Frequency : 3491.912 MHz CPU Cache : 15360 KB Total Disk : 49.8 GB (1.7 GB Used) Total Mem : 908 MB (527 MB Used) Total Swap : 0 MB (0 MB Used) System uptime : 0 days, 0 hour 22 min Load average : 0.00, 0.02, 0.11 OS : CentOS 7.7.1908 Arch : x86_64 (64 Bit) Kernel : 3.10.0-1062.4.3.el7.x86_64 TCP CC : cubic Virtualization : Hyper-V Organization : AS24940 Hetzner Online GmbH Location : Frankfurt am Main / DE Region : Hesse---------------------------------------------------------------------- I/O Speed(1st run) : 304 MB/s I/O Speed(2nd run) : 313 MB/s I/O Speed(3rd run) : 313 MB/s Average I/O speed : 310.0 MB/s---------------------------------------------------------------------- Node Name Upload Speed Download Speed Latency Speedtest.net 29.17 Mbps 605.76 Mbps 0.94 ms Beijing CU 27.21 Mbps 355.66 Mbps 245.48 ms Shanghai CT 0.49 Mbps 25.68 Mbps 236.93 ms Shanghai CU 27.23 Mbps 381.04 Mbps 286.30 ms Shenzhen CU 28.06 Mbps 360.45 Mbps 324.82 ms Shenzhen CM 28.32 Mbps 427.49 Mbps 233.97 ms Hongkong CN 26.26 Mbps 312.03 Mbps 196.09 ms Singapore SG 23.95 Mbps 413.83 Mbps 252.61 ms Tokyo JP 27.87 Mbps 124.35 Mbps 273.54 ms---------------------------------------------------------------------- 可以看見，這款VPS與中國聯通、中國移動的連接相當不錯，可以跑滿30Mbps的帶寬。而中國電信則有點凄慘，上載只能跑到500Kbps左右。 連接海外的鏈路十分不錯，也能幾乎跑滿。可能是因爲云筏科技對服務器進行了升級，整體表現比之前他家的大盤鷄要好上一些。 IPv6架設Nextcloud實戰純IPv6也可以架設網站，并且讓純IPv4用戶可以正常訪問。原理是使用CDN中轉網站的流量，讓CDN服務商幫我們把IPv4請求轉發成IPv6請求。這裏使用最常用的Cloudflare輔助純IPv6的網站架設。 這裏使用輕量化的Caddy作爲主要的網頁伺服器。雲筏科技即便改版後加配到大數據盤也不算很貴，拿來當作Nextcloud網盤為封鎖地區中轉Google Drive也挺不錯的。 配置Cloudflare前文提到，Cloudflare可以將IPv4流量透過他們的CDN伺服器，轉發到我們的IPv6 VPS上。 如果你在Cloudflare上沒有域名，可以將自己的域名綁定到Cloudflare。如果你沒有域名，可以去Freenom免費注冊一個域名。 打開Cloudflare，進入自己的域名。打開域名的DNS頁面 按下新增記錄，將左邊的類型改成AAAA，名稱取一個自己習慣的名稱，然後將伺服器的IPv6位址填在右邊IPv6位址裏面，最後確保Proxy狀態下面的那朵云是橙色的（這代表你的流量會經過Cloudflare代理），便可以按下儲存等待DNS生效。 方法一：使用Caddy+PHP安裝Nextcloud上網找了個自動化脚本自動安裝Caddy和PHP。 1wget https://git.io/vra5C -O - -o /dev/null|bash 這個脚本是Caddy管理工具，跑完之後應該會提示輸入caddy使用脚本。官方自帶的使用説明如下 12345678910111213141516caddy start - Start Caddy Web Server.caddy stop - Stop/Shutdown Caddy Web Server.caddy reload - Reload Caddy Web Server.caddy restart - Restart Caddy Web Server.caddy status - Check Caddy Web Server is running or not or just run &apos;caddy&apos;.caddy install - Install Caddy Web Server on fresh OS.caddy install-naked - Install only Caddy Web Server and no prompt.caddy edit - Edit Caddyfile using nano or default editor.caddy service - Make Caddy Web Server start on boot (upstart/systemd). Not required because we install service on install.caddy update - Update Caddy Web Server.caddy delete - Uninstall Caddy Web Server and data. We would prompt you if you want to keep data.caddy version - Print version information.caddy about - About Caddy Web Server Installer. 輸入caddy install安裝Caddy與PHP 1234567[root@ ~]# caddy install Downloading Caddy Web Server v1.0.4 for 64bit... Extracting Caddy Web Server to /opt/caddyserver... [DONE] Are you gonna run php site? [y/N]: y 詢問你是否架設PHP網站，脚本自動輸入了y。如果選擇y的話會安裝PHP依賴文件，因爲要架設基於PHP編寫的Nextcloud，這裏只需要直接按回車即可，不需要輸入y。輸入之後便會繼續安裝，安裝完成之後會提示你輸入網站信息。 123456789101112131415Installing required php files... [DONE]Installed &apos;php-fpm php-cli php-curl curl sudo&apos;Fixing php sock issue... [DONE]Creating user &apos;caddy&apos;... [DONE]Binding port using setcap... [DONE]Creating startup service... DONECreated symlink from /etc/systemd/system/multi-user.target.wants/caddy.service to /etc/systemd/system/caddy.service.Enter your domain nameSeperated by commaDomain name:Enter your email for automated sslEmail: 提示輸入申請SSL證書的Email，輸入off，表示不需要SSL，待會用自簽證書替代letsencrypt的證書。 1234567891011/etc/Caddyfile createdindex file created/var/caddywww/index.htmlPHP-info file created/var/caddywww/info.phpDone. Caddy has been installed :)Run caddy start to start Caddy Web Server[root@nzZKNJ1000562 ~]# 先打開/etc/Caddyfile編輯網站詳情 1[root@ ~]# vi /etc/Caddyfile 修改成類似以下格式 12345678example.com,:80 &#123; root /var/caddywww gzip tls self_signed log /var/log/caddy/access.log errors /var/log/caddy/error.log fastcgi / 127.0.0.1:9000 php&#125; 其中，tls行後面的self_signed表示讓Caddy自簽證書，用於加密伺服器到Cloudflare的流量。example.com是你的域名。填寫完之後按下esc，輸入:wq保存退出。 安裝Nextcloud在伺服器目錄裏面下載Nextcloud的在綫安裝脚本，並啓動Caddy。 12345cd /var/caddywww &amp;&amp; wget https://download.nextcloud.com/server/installer/setup-nextcloud.php &amp;&amp; caddy start# 如果你是Centos7，需要輸入以下命令開啓端口firewall-cmd --add-port=443/tcp --permanentfirewall-cmd --add-port=80/tcp --permanentfirewall-cmd --reload 然後，在瀏覽器打開https://你的域名/setup-nextcloud.php。安裝Nextcloud。 下一步，選擇Nextcloud的子目錄，輸入.以安裝在網站的根目錄 等待安裝完成即可。 方法二：使用snap安裝Nextcloud（推薦）輸入以下命令安裝snap和Nextcloud 1yum install snapd -y &amp;&amp; systemctl enable --now snapd.socket &amp;&amp; sleep 10 &amp;&amp; snap install nextcloud 然後，在瀏覽器打開https://你的域名/setup-nextcloud.php。注冊管理員賬號即可。 總結雲筏科技這款VPS速度尚可，要這麽迷你款的vps跑Nextcloud這種級別的軟件的確有點吃不消。後續可能會安裝V2ray測試一下實際的代理連接速度。]]></content>
      <categories>
        <category>生活心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
        <tag>技術相關</tag>
        <tag>VPS</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反向代理Github，加速國內vps從Github扒文件的速度]]></title>
    <url>%2F2020%2F02%2F09%2F%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86github%2F</url>
    <content type="text"><![CDATA[前言最近在折騰國内vps，實現反向翻墻，方便看國内的正版資源，加速國内網盤的訪問以及免報備B站直播。但是架設各種服務的時候脫離不了Github這個世界上最大的同性交友網站。 於是想到了先前很久都在用的寶塔vps，創建了一個靜態站做反向代理。 需要使用的工具 國内能正常訪問的海外Vps 寶塔面板 過程若沒有安裝寶塔面板，先用以下命令安裝寶塔 1curl -sSO http://download.bt.cn/install/new_install.sh &amp;&amp; bash new_install.sh 建議使用screen命令後臺安裝，安裝寶塔面板有編譯過程，耗時較久。 過程可以把自己擁有的域名解析到你的vps，若沒有域名建議使用Freenom注冊免費域名。這裏不再演示如何注冊與解析域名。 安裝完成後，根據推薦安裝套件安裝LNMP套裝。安裝完畢后打開網站選項卡，添加站點。 然後輸入自己的域名（把your.domain填寫為其他已經解析的域名），填寫備注和更改php版本為純靜態。 創建完成後，點擊網站名，會進入設置頁面，設置頁面先選擇SSL選項卡，然後選擇Let’s Encrypt，創建免費的SSL證書（當然你可以選擇不使用https，只使用http） 然後勾上域名的勾勾，點擊申請（注意申請的時候必須已經解析好域名），申請完畢之後就會出現部署成功的，顯示密鑰與證書的畫面。 點擊左邊選項卡的反向代理，添加反向代理，然後如下填寫 提交之後，你的反向代理應該已經生效了，可以試著訪問自己的網站看看是否可以正常使用。]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>反向代理</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[記錄B站ban了海外直播后的艱辛反向翻墻歷程]]></title>
    <url>%2F2020%2F01%2F13%2F%E8%A8%98%E9%8C%84B%E7%AB%99ban%E4%BA%86%E6%B5%B7%E5%A4%96%E7%9B%B4%E6%92%AD%E4%B9%8B%E5%BE%8C%E7%9A%84%E8%89%B1%E8%BE%9B%E5%8F%8D%E5%90%91%E7%BF%BB%E5%A2%BB%E6%AD%B7%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[發生了什麽事情緣起于2018年我有一天突發奇想想在Bilibili直播玩游戲，或者稍微編編曲。於是我開開心心的打開了我常用的B站賬號，打開直播中心，按下開始直播按鍵，它提示我系統升級維護中。我就乖乖的等了幾天，再次打開，仍然是升級維護中。 於是我找了客服，詢問是什麽升級維護。客服回答得含含糊糊，口齒不清，就是一股不想回答的氣息，氣得我反向抽烟燙到自己嘴巴。我放下這個事情，把心思擺回到工作學習上。慢慢忘了這檔子事情。 三個月後，開始看vtuber。那時候已經是9102年，vtuber也時不時會在b站做做b限。在dd的途中，我突然又想起來關於我直播間的那檔事情。再去開了一下，依然是系統升級維護中。這時候我感到事情并不簡單。 質問了一輪客服，問了問不同的大佬，大概瞭解到是部分海外人士在b站直播的時候提及敏感話題（就是台灣香港南北韓兩伊印度新疆西藏balabala），導致只有b站做了這種一刀切的劣質處理。本來作爲一個剛剛起步的小公司，一刀切一段時間整頓這個玩意也是無可厚非，畢竟是在中國大陸做生意，有些規則確實需要遵循。我心想沒準過多幾個月就能研討出整套的解決方案了吧。 於是到了2019年年尾，我想給群友演示編曲和游戲的時候，感覺qq的直播極爲弱智，突然又回想到了b站的事情。再上去一看，仍然是系統升級維護中。 成，那我自己看看你到底在維護什麽。 身份認同與身份證明香港居民不配當中國人，全中國的互聯網公司都是這麽定義的。現在，港臺居民注冊b站想要“開通直播功能”，据b站官方所稱需要拍護照或者回鄉證進行實名認證。實際上，我早在2016年已經完成實名認證，2017年也確實可以正常直播，但到了2018年，這個條款説明也沒有變更，不過我就是無法正常開啓直播功能了。 据不同的消息來源所稱，現在免報備直播主要受到以下兩點限制： 僅允許大陸IP進行免報備直播 僅允許大陸居民身份證實名認證用戶進行免報備直播 報備：向b站官方進行活動審核，以進行直播 據我所知，無大陸居民身份證實名認證的賬戶無論是否大陸IP與是否報備，一般都不會允許進行直播。也就是説，在B站現今實際情況下，港澳臺與海外用戶是無法通過正常的手段進行個人直播的。而且，包括港澳臺和海外用戶，所有的實名認證操作均不可逆不可更改。 在B站，你想自由的直播，需要僞裝成一個住在大陸的大陸人。 手段進入正篇。 第一個問題： 僅允許大陸IP進行免報備直播。解決方法其實挺簡單明瞭。只需要在大陸購置一臺vps架設代理服務器便解決了問題。 不過，畢竟只有直播軟件和瀏覽器會受到b站的ip審查，如果通過普通的代理方法，要麽只能代理瀏覽器，要麽就是全局代理。這個情況和大陸居民翻出來YouTube進行直播的情況是極爲類似的。我在這裏使用了以下兩個工具： SSR-win：將SSR協議轉換爲HTTP協議。 Proxifier：為不同的軟件配置不同的網路方案，這軟件支持HTTP代理協議。 Proxifier的教程不少，如果有一點點代理相關知識的人應該知道代理實際上就是讓你的代理服務器成爲你的軟件請求的代理人。我們只需要把OBS以及一個專門用來訪問B站的瀏覽器（例如Firefox）代理到大陸，別的軟件不需要回國。具體的教程網上很多，這裏不過多贅述，僅僅提一點。 規則設置中，OBS安裝目錄下的所有exe麻煩全部勾上去，完成後，方案下被代理的軟件列表應如下： 1obs64.exe; obs-ffmpeg-mux.exe; obs-browser-page.exe; vlc.exe; node.exe 再提一個比較重要的事情。大陸的Vps服務器近兩年價格愈加嚇人，一般的1M VPS月租都要六七十塊錢，3M帶寬的甚至需要上三四百塊錢的月租，所以現在可能有許多人會選擇NAT VPS。 但要注意，NAT VPS在不同的綫路下的表現差距特別大。一般來説，接近上海和深圳這兩個出口點的服務器都會比較優質，電信的出口綫路質量一般都比另外兩大運營商要優秀。如果你和我一樣在香港，便宜的NAT VPS服務器裏可能只有東莞的VPS可以選擇。深圳地價高沒什麽小廠商會去開機房，大部分機房都在江蘇安徽浙江一帶，那一帶的對外綫路質量又參差不齊。具體可以上網查找別人關於翻墻中轉NAT VPS的選擇心得。 第二點，或許有兩個方法。 第一個方法，也是我本人用的方法，就是請求信任的人幫忙認證，注冊新的賬號，成爲你在B站上的靈魂。這個方法簡單且快捷，但是實行起來卻會有不少疑慮和擔心。而且，如果是特純種香港人台灣人，和大陸聯係不多，這個方法更是比較難適用。 第二個方法，就是返回大陸申請居住證，用居住證進行實名認證。這個方法我沒有實證過，關於如何申請居住證以及有什麽條件，我也沒有實際操作過。這裏僅僅是提出一種可能性。（但僅僅爲了閑暇時間直播而申請居住證，未免太大費周章） 怠惰總而言之，B站作爲一個互聯網公司，坐擁全國最多的綜合視頻流量，身爲全國綜合視頻和直播的壟斷龍頭，理應有相應的執行力和技術能力解決政治言論上的杯葛。即便是報備，也可以將報備流程做的系統化和程序化，在網頁上實現類似視頻和封面審核的報備流程。但是這并沒有發生，實際原因爲何，也不得而知，只能任我們猜想。]]></content>
      <categories>
        <category>生活心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro的KDE安裝包之默認密碼]]></title>
    <url>%2F2019%2F11%2F10%2Fmanjaro_kde_passwd%2F</url>
    <content type="text"><![CDATA[manjaro安裝過程中會自動鎖屏，而且系統自帶密碼，manjaro賬戶的默認密碼為manjaro。]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA非對稱加密算法學習筆記]]></title>
    <url>%2F2019%2F11%2F10%2Fstudy_of_rsa%2F</url>
    <content type="text"><![CDATA[這是啥RSA算法是一種非對稱加密算法，他的原理完全基於歐拉定理，而歐拉定理基於歐拉函數……歐拉函數基於互質……互質則確定了兩個數字之間的唯一性…… 123歐拉函數：φ(n) = n-1歐拉定理：如果兩個正整數a和n互質，則n的歐拉函數 φ(n) 可以讓下面的等式成立：a^φ(n)%n=1其中%是取餘數之含義]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>加密</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用Windows版本的dd工具]]></title>
    <url>%2F2019%2F11%2F09%2FUsege_dd_for_windows%2F</url>
    <content type="text"><![CDATA[Windows版本的dd與Linux / macOS下的差異不大，只不過驅動器名稱相當的詭異。在windows下，dd命令使用以下標識來代表驅動器 1\\.\a: #a代表盤符 將1.img刻入e盤即為 1dd.exe if=1.img of=\\.\e]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系統學習框架 —— 如何開始學習完全不懂的一樣學科]]></title>
    <url>%2F2019%2F10%2F27%2FStudying_system_theory%2F</url>
    <content type="text"><![CDATA[任何的學習都需要一定的耐心、通過不斷的實踐纍積經驗。不過，“學習”具體是什麽，我們是如何學習的？老師是如何教導我們知識的？ 基礎的要素任何的學習都需要瞭解以下幾個學科要素 術語：任何理論都需要一套術語對學科内發生的現象進行描述或總結，方便邏輯思考。 舉例而言，音樂中的CDEFGAB七個音的名稱是用於描述7個音高的，拍子數是用於描述音之間的時間關係的。 思維模式：任意的理論]]></content>
      <categories>
        <category>生活心得</category>
      </categories>
      <tags>
        <tag>學習</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo學習筆記 —— 多端同步、Github Pages部署、更改主題、評論功能（四）]]></title>
    <url>%2F2019%2F08%2F22%2FHEXO_STUDY_4%2F</url>
    <content type="text"><![CDATA[關於多端同步依然還有一些東西可以略微分享。我們可以使用Github的webhook功能，對儲存源碼和文章md文件的repo進行pull操作后，自動將網頁輸出然後push到博客端。 講實話，這玩意真的挺麻煩，我折騰了特別久，結果還是最最最簡單的辦法：http訪問就推送，最爲方便。 在VPS上安裝hexo的運行環境這方面已經在第一篇文章詳細講過，無非就是安裝nodejs, hexo-cli等等。 這裏不重複闡述 給VPS設置在Github上的通用SSH授權輸入以下代碼創建一個ssh key 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 然後複製~/.ssh/id_rsa.pub文件内的所有内容，打開github的setting中的SSH and GPG keys 添加SSH Key即可 在VPS上克隆自己創建的庫在第二篇文章中我們創建了一個同步庫，裏面存放著hexo的源碼，用來進行多端同步。現在將他克隆到vps上 123456mkdir autocd autogit clone git@github.com:yourname/blog.gitcd blognpm installgit pull 然後安裝pm2管理後臺應用 1npm install -g pm2 之後，在本地創建一個deploy.js，用nodejs寫一個監聽http請求的脚本 1234567891011var http = require('http');var port = 3000; //監聽端口var command = 'sh ./deploy.sh' //運行指令http.createServer(function(req, res)&#123; res.writeHead(200, &#123;'content-type': 'text/plain'&#125;); deploy = require('child_process').exec(command,&#123;&#125;,function(err,stdout,stderr)&#123; console.log('deploy.') &#125;); res.end('It works');&#125;).listen(port); 再創建一個deploy.sh進行pull和hexo g -d操作。 1234#!/bin/bashgit pullhexo cleanhexo g -d 這時候監聽服務應該可以運作了。先在別的設備更改一下hexo源碼並push到github，然後試著運行以下代碼。 1node ./deploy.js 訪問vps的http://ip:3000。若你的ip為100.100.100.100，則訪問http://100.100.100.100:3000，不出意外網頁會返回It works，vps控制臺會輸出deploy. 按下Ctrl+C關閉node，輸入pm2 start deploy.js將服務運行在後臺，然後開始配置github Github端的配置進入你的同步代碼倉庫，點擊上方的Setting。 然後點擊左方的Webhooks，添加新的webhook 進入后， 在Payload URL中填入你剛剛訪問的網址（包括端口） 直接點擊Add webhook。 然後使用另一臺機器，更改一下你的文章，將blog文件夾更新到github，觀察博客頁面有沒有變化。]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[讓Markdown文檔一秒轉換為Keynote演示文檔 —— md2key學習筆記]]></title>
    <url>%2F2019%2F08%2F21%2F%E8%AE%93Markdown%E6%96%87%E6%AA%94%E4%B8%80%E7%A7%92%E8%BD%89%E6%8F%9B%E7%82%BAKeynote%E6%BC%94%E7%A4%BA%E6%96%87%E6%AA%94%20%E2%80%94%E2%80%94%20md2key%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%2F</url>
    <content type="text"><![CDATA[引言Keynote是一個蘋果自家的演示文檔軟件，有許多強大的預設，動畫效果十分驚人md2key是一個讓Markdown格式的文檔轉換為Keynote文檔的工具，由k0kubun開發維護GitHub主頁 安裝12# 僅限macOS用戶gem install md2key 使用方法 創建一個Keynote文檔 添加一張你想要的樣式幻燈片作為封面，然後把第一張幻燈片刪除 創建第二張幻燈片，這張幻燈片的樣式作為內頁 保持文檔開啟，在終端直接輸入md2key markdown.md 進階用法 點擊右方的“編輯母版幻燈片” 在Keynote中給任何你將會用到的母版幻燈片命名為“cover”“h1”“h2”⋯⋯“h5” cover對應第一段“#”，第一個#之後的文字會印刷在封面頁，h1對應一個#，h2對應兩個#⋯⋯ 例如： 12345678910# The presentation@k0kubun## Hello worldI'm takashi kokubun- This is a pen- Nested item is available## How are you?- I'm fine thank you]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Keynote</tag>
        <tag>PPT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo學習筆記 —— 多端同步、Github Pages部署、更改主題、評論功能（三）]]></title>
    <url>%2F2019%2F08%2F20%2FHEXO_STUDY_3%2F</url>
    <content type="text"><![CDATA[主題 —— NexT進入hexo目錄，然後下載主題 12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next 編輯hexo目錄下的_config.yml，把主題改成改成theme: next。 然後編輯theme/next/_config.yml 搜索schemes關鍵詞，將scheme: Gemini前的#號去掉，然後注釋掉默認的scheme: Muse 運行以下命令更新主題（若你有根據上一篇編寫push腳本） 1./push 評論Hexo是一個靜態博客生成工具，生成的頁面僅有展示功能，而沒有提交功能。 以下內容參考 https://www.jianshu.com/p/d68de067ea74 如果需要實現評論，Hexo是沒法接收網頁傳來的表單信息的,則需要借助相關的服務。這裏使用的是Disqus 進入官方站點注冊後登錄，點擊GET START，然後按下下圖所示按鈕]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo學習筆記 —— 多端同步、Github Pages部署、更改主題、評論功能（二）]]></title>
    <url>%2F2019%2F08%2F20%2FHEXO_STUDY_2%2F</url>
    <content type="text"><![CDATA[同步多端……真正麻煩的事情來了根據剛剛提到的文件目錄結構 12345678|-- _config.yml #配置文件|-- package.json #hexo的依賴，插件信息也保存在這文件內|-- scaffolds #標準模板，一般不需要關心|-- source #資源目錄，文章與各種附件也都保存在這 |-- _posts #文章文件夾|-- themes #主題|-- .gitignore #git同步的時候忽略的目錄與文件|-- public #生成後的靜態博客文件夾 有同步意義的是_config.yml, package.json, source/, themes 最重要的是source文件夾，裏面包含了可以引用的圖片、文章文件以及各種附加的小附件。 Google Drive, 百度網盤, Dropbox等同步網盤使用Google Drive一類簡單粗暴的多端同步網盤來同步我們的hexo文檔和配置，缺點就是node相關的文件也都會一並同步，好處就是特別省事。 直接將整個目錄復制到Google Drive即可，之後所有操作都在掛載後的Google Drive裏面進行。 在另外一臺機器，安裝Google Drive同步程序，然後將hexo目錄設置爲同步以及離線可用，之後整個Hexo端便會一直保持着最新的文件。 其他網盤同理 Github同步這個方案配置比較麻煩，但是後期使用問題較少，挺多大佬也是使用這個方案進行多端同步 以下是步驟 先在Github建立一個私人庫，專門存放Hexo部署程序 在Hexo的目錄下，運行git init 修改.gitignore爲以下內容 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 執行以下代碼，進行第一次推送代碼 1234git add .git commit -m "first commit"git remote add origin git@github.com:username/library.gitgit push -u origin master 創建一個名爲push的文件，將以下代碼輸入進去 12345#!/bin/bashgit add .git commit -m `date +%Y-%m-%d-%H%M`git push origin masterhexo g -d 輸入chmod +x push，給腳本增加運行權限 輸入./push嘗試推送 之後，新的機器先安裝Hexo，再輸入git clone git@github.com:username/library.git，再進入克隆目錄內，輸入npm install安裝依賴即可。 每次編輯完文章，輸入./push推送，換到另一臺電腦想繼續編輯時，輸入git pull拉取最新檔案下來即可。 2019-08-22更新 如果你有自己的VPS服務器，可以使用github的webhook功能進行自動更新，具體可以查看這篇文章 需要將push文件修改成以下内容才能使用webhook自動更新網頁端 1234#!/bin/bashgit add .git commit -m `date +%Y-%m-%d-%H%M`git push origin master]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo學習筆記 —— 多端同步、Github Pages部署、更改主題、評論功能（一）]]></title>
    <url>%2F2019%2F08%2F20%2FHEXO_STUDY_1%2F</url>
    <content type="text"><![CDATA[舊的博客是用Typecho做的，什麼都挺好，就是這個博客沒法直接上載.md文件，備份也顯得挺麻煩。 在15年的時候嘗試搭建Hexo博客，那時候的Hexo的配置流程比現在復雜特別多。現在比之前方便多了，想着要不要遷移到Hexo。 基本了解Hexo主要由三個部分組成 生成端 生成更新後的博客靜態頁面 推送端 負責把靜態頁面推送到網頁 網頁端 提供網頁瀏覽服務 一般生成端和推送端整合在一起，網頁端獨立部署在虛擬主機或者Github Pages、Coding Pages上。但是文章內容都是保存在生成端的source/_posts，要是換一臺機子就沒法同步文章，也沒法推送文章。 安裝hexo首先需要安裝nodejs與npm，在官網上也有不同系統使用包管理器安裝的指引 1234567891011# Using Ubuntucurl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -sudo apt-get install -y nodejs# Using Debian, as rootcurl -sL https://deb.nodesource.com/setup_12.x | bash -apt-get install -y nodejs# Using RHEL, CentOS, CloudLinux and Fedora, as rootcurl -sL https://rpm.nodesource.com/setup_12.x | bash - 安裝完nodejs之後使用node -v與npm -v查看nodejs與npm的版本。可以使用npm install npm進行升級，然後使用npm安裝hexo。 12345678mkdir blog &amp;&amp; cd blognpm install -g hexo-clihexo init #初始化hexo#輸入以下命令檢查網站雛形hexo new testhexo g #構建靜態頁面hexo s #開啓服務器 完成之後在瀏覽器輸入網址localhost:4000。應該會看到生成的test頁面和hello world頁面。 hexo的目錄結構如下 12345678|-- _config.yml #配置文件|-- package.json #hexo的依賴，插件信息也保存在這文件內|-- scaffolds #標準模板，一般不需要關心|-- source #資源目錄，文章與各種附件也都保存在這 |-- _posts #文章文件夾|-- themes #主題|-- .gitignore #git同步的時候忽略的目錄與文件|-- public #生成後的靜態博客文件夾 常用的命令有以下幾條 123456789101112131415npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客#命令简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #啓動伺服器hexo d == hexo deploy #推送部署hexo server #Hexo監視文件變動並自動更新，無需重啓服務器hexo server -s #靜態模式，只監視public文件夾下的內容hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定義 IPhexo clean #清除緩存 而_posts內.md文件的文章大致結構如下 12345678910---title: [標題]date: [YYYY-MM-DD HH：MM：SS]tags:- [tag1]- [tag2]- [tag3]categories: [分類]---[文章內容] 推送網站剛剛介紹文件目錄結構提到有一個_config.yml配置文件，使用atom或你喜歡的編輯器打開這個文件，在最後幾行會看到以下字樣 123deploy: type: #推送類型 repo: 這個就是hexo自帶的網站推送功能的配置行，這次我使用Github中自帶的Github Pages當作網頁端，而這需要安裝hexo的git推送插件 1npm install hexo-deployer-git --save 然後修改_config.yml 1234deploy: type: git repo: yourname.github.com branch: master 可以看這裏查看如何配置Github以實現二級域名訪問 其他的部署渠道可以在這裏查看如何部署 修改完_config.yml後，分別輸入以下三條命令 123hexo cleanhexo ghexo d 然後你的第一次部署便完成了。訪問 yourname.github.com，應該可以看到你部署的hexo博客了。 接下來要處理的是如何同步多端。]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Proxmox中安裝macOS Mojave並設置直通顯卡]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%9C%A8Proxmox%E4%B8%AD%E5%AE%89%E8%A3%9DmacOS%20Mojave%E4%B8%A6%E8%A8%AD%E7%BD%AE%E7%9B%B4%E9%80%9A%E9%A1%AF%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[在PVE中安裝macOS Mojave並設置直通顯卡先決條件： 8G或以上內存 支持虛擬化以及SSE4.2的cpu 包括AMD與INTEL 1 安裝PVE安裝教程此處安裝方法與一般的方法相同，推薦將pve系統安裝到usb設備 2 創建macos安裝鏡像在linux或macos系統下運行以下命令 123wget https://raw.githubusercontent.com/thenickdude/OSX-KVM/master/fetch-macOS.pychmod +x fetch-macOS.py./fetch-macOS.py 在選單中選擇最新的iso，等待下載完成後，運行以下命令，將dmg包轉換成iso包 12345678# 安裝dmg2img 若你是deb包管理系以外的系統，可以自行查找如何安裝dmg2imgapt-get install dmg2img -y# 利用dmg2img將基本系統dmg鏡像轉為iso鏡像dmg2img BaseSystem.dmg Mojave-installer.iso# 若你是macOS，請使用以下命令hdiutil convert BaseSystem.dmg -format RdWr -o Mojave-installer.isomv Mojave-installer.iso.img Mojave-installer.iso 然後下載Clover 123456# Ubuntu &amp; Debianapt-get install unzip -y# Centos &amp; RHELyum install unzip -y# 取得cloverwget https://github.com/thenickdude/OSX-KVM/releases/download/clover-r4920/clover-r4920.iso.zip &amp;&amp; unzip clover-r4920.iso.zip 然後將clover-r4920.iso與Mojave-installer.iso上傳到PVE中 3 在網頁中創建虛擬機 OS頁面選擇Clover ISO進行引導 系統選擇其他（other） System頁面的顯示卡選擇VMware兼容 BIOS選擇OVMF Machine選擇q35 硬盤選擇SATA，緩存設置成Write back（不安全） CPU的類型設置成Penryn 網卡設置成Vmware vmxnet3 點開虛擬機的硬件選項卡，添加Mojave-installer.iso，選擇ide通道的cd-ram 先不要啟動虛擬機，在ssh中打開/etc/pve/qemu-server/你的VMID.conf 1nano /etc/pve/qemu-server/你的VMID.conf 然後輸入以下代碼 1args: -device isa-applesmc,osk=&quot;ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc&quot; -smbios type=2 -cpu Penryn,kvm=on,vendor=GenuineIntel,+invtsc,vmware-cpuid-freq=on,+pcid,+ssse3,+sse4.2,+popcnt,+avx,+aes,+xsave,+xsaveopt,check -device usb-kbd,bus=ehci.0,port=2 將兩個驅動器的配置中的cdrom刪除，加入cache=unsafe最後的文檔應該看起來像這樣 1234567891011121314151617181920args: -device isa-applesmc,osk=&quot;ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc&quot; -smbios type=2 -cpu Penryn,kvm=on,vendor=GenuineIntel,+invtsc,vmware-cpuid-freq=on,+pcid,+ssse3,+sse4.2,+popcnt,+avx,+aes,+xsave,+xsaveopt,check -device usb-kbd,bus=ehci.0,port=2balloon: 0bios: ovmfboot: cdnbootdisk: ide2cores: 4cpu: Penrynefidisk0: vms:vm-144-disk-1,size=128Kide0: isos:iso/Mojave.iso,cache=unsafeide2: isos:iso/clover-r4920.iso,cache=unsafemachine: q35memory: 8192name: mojavenet0: vmxnet3=xx:xx:xx:xx:xx:xx,bridge=vmbr0,firewall=1numa: 0ostype: othersata0: vms:vm-144-disk-0,cache=unsafe,size=64Gsmbios1: uuid=xxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxsockets: 1vga: vmware 設置完畢後，根據patch-ovmf-to-support-macos-in-proxmox-5-1 來安裝OVMF庫 For PVE 6 123456789101112131415161718192021# Add missing localeecho &quot;en_US.UTF-8 UTF-8&quot; &gt;&gt; /etc/locale.genlocale-genexport LC_ALL=en_US.UTF-8# Add tools and build dependencies:apt updateapt install build-essential git lintian debhelper iasl nasm \ python uuid-dev gcc-aarch64-linux-gnu bc python3-distutils -y# Clone my patched sourcegit clone -b macos-support-proxmox-6.0 https://github.com/thenickdude/pve-edk2-firmware.git# Build itcd pve-edk2-firmwaremakedpkg -i pve-edk2-firmware_*.deb# Prevent it from being replaced later by apt upgrade:apt-mark hold pve-edk2-firmware 4 設置直通首先，編輯grubvim /etc/default/grub將GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet&quot;改為GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet intel_iommu=on video=efifb:off&quot;（若是amd則改為amd_iommu=on） 執行update-grub命令更新grub信息最後輸入dmesg | grep -e DMAR -e IOMMU命令檢查是否有錯然後編輯/etc/modules nano /etc/modules在最尾加入以下四行 1234vfiovfio_iommu_type1vfio_pcivfio_virqfd 再次輸入dmesg | grep ecap命令檢查設備是否支持iommu然後執行以下命令將驅動加入黑名單 123echo &quot;blacklist radeon&quot; &gt;&gt; /etc/modprobe.d/blacklist.confecho &quot;blacklist nouveau&quot; &gt;&gt; /etc/modprobe.d/blacklist.confecho &quot;blacklist nvidia&quot; &gt;&gt; /etc/modprobe.d/blacklist.conf 執行update-initramfs -u命令更新信息執行lspci，找出顯卡的代號（例如01：00），然後執行lspci -n -s 01:00得到類似以下的輸出 1201:00.0 0300: 10de:1d01 (rev a1)01:00.1 0403: 10de:0fb8 (rev a1) 其中10de:1d01與10de:0fb8是vendor IDs將vendor IDs指定到VFIO模塊 1echo &quot;options vfio-pci ids=10de:1d01,10de:0fb8&quot; &gt; /etc/modprobe.d/vfio.conf 進入web管理介面 在vm的硬件選項卡中編輯添加PCI設備 選定顯卡對應的01:00.0與01:00.1 在01:00.0（顯示設備）中勾選 PCI-Express All Functions 主GPU 檢查文件/etc/pve/qemu-server/YOUR-VM-ID.conf 確保01:00後的參數正確 e.g.hostpci0: 01:00,x-vga=1,pcie=1 然後，直通鼠標鍵盤到VM中，添加USB設備，選擇鼠標鍵盤，然後添加到VM 5 安裝Mojave現在啟動你的虛擬機，若你設置了直通，啟動的一瞬間會發生以下事情 連接在你顯卡的顯示器應該會從PVE的ttl介面變為黑屏，然後變成OVMF UEFI啟動介面。 你的鍵盤鼠標這時候也可以直接控制虛擬機。 在啟動的時候趕快按下F2以進入OVMF設置畫面。 進入Device Manager 選擇OVMF platform configuration 設置分辨率為1920x1080 保存設置 在根菜單下選擇Reset（不是continue） 然後你應該進入了Clover，接下來跟著指引安裝系統全部安裝完畢之後，再次啟動時 手動按下F2 選定Clover啟動項 然後才會看到磁盤內的Mac系統。進入Mac系統後，打開終端，輸入diskutil list以檢查設備然後輸入sudo dd if=&lt;Clover CD的EFI分區&gt; of=&lt;硬盤的EFI分區&gt;將Clover安裝到硬盤中 你也可以忽略這一步，將Clover CD永久掛載在虛擬機下 關機，移除CLover CD，從硬盤啟動。]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>Proxmox</tag>
        <tag>黑蘋果</tag>
        <tag>macOS</tag>
        <tag>直通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安裝Proxmox VE]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%AE%89%E8%A3%9DProxmox%20VE%2F</url>
    <content type="text"><![CDATA[先決條件 支持VT-d或AMD-V的CPU 8G或以上的可完全擦除磁盤，或8G以上的U盤用作Proxmox VE的系統盤 另外一隻2G以上的U盤 下載Proxmox VE的安裝鏡像官方載點 安裝過程將ISO文件寫入2G以上大小的U盤，製作啟動介質 12dd if=~/Downloads/Proxmox.iso of=/dev/sdx# Proxmox.iso是你下載的鏡像，而/dev/sdx是你的U盤設備（2G以上） 寫入完畢之後，輸入命令reboot重啟電腦 進入電腦UEFI設置介面，開啟VT-d或AMD-V，設置2G的閃存盤為首啟動項 若你使用8G以上的U盤作為系統盤，請在這個時候插入 保存UEFI設置，重啟電腦 啟動Proxmox VE安裝程序，選擇Install Proxmox VE，進入自檢畫面，等待數秒至數分鐘 同意協議，按“Agree” 選擇硬盤，請根據磁盤容量選擇正確的硬盤 Proxmox VE安裝不可以選擇安裝在某個硬盤的某個分區 一旦選擇安裝，便會重新分區整個硬盤，請準備可以完全擦除的磁盤設備 設定國家、時區與鍵盤，在Country輸入China、Taiwan或Hong Kong都會直接填充時區信息 設定管理員root帳號密碼郵箱 設定主機名、IP、網關、掩碼與DNS，設置完畢後點擊Next開始安裝 安裝完畢需要手動重啟，點擊右下角Reboot重啟 Proxmox VE會在啟動後於主機的ttl控制台中顯示Web控制台的URL，此URL只接受HTTPS使用安裝的時候設置的root帳戶密碼，登入網頁端，顯示Proxmox VE的網頁控制台。]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>Proxmox</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[實現家庭綜合服務器——給Proxmox VE中的Win10直通顯卡]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%AF%A6%E7%8F%BE%E5%AE%B6%E5%BA%AD%E7%B6%9C%E5%90%88%E6%9C%8D%E5%8B%99%E5%99%A8%E2%80%94%E2%80%94%E7%B5%A6Proxmox%20VE%E4%B8%AD%E7%9A%84Win10%E7%9B%B4%E9%80%9A%E9%A1%AF%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[前情提要話説我弟最近上中學，他開始需要使用電腦做學校的課業，而我家裏有一臺chromebook、台機和一臺特別破舊的超極本。 超極本的發熱已經接近70度，可以把人手烤焦，chromebook的系統不支援他學校的CD軟體，而我的臺機，有太多的不可見人的東西，更是不能給他使用。 但是教育乃一切之本，他的生日也臨近，想給他送個禮物，於是看到了我家不斷跑著OVM、ikuai、web-server和域名ddns的伺服器，突然覺得，可以壓縮一下前面幾個服務的性能，給他搭建一個能用的電腦操作平臺。 大致的想法就是買個基礎顯卡，買個固態硬盤直通到虛擬機，然後直通USB口，把這些綫捆成一坨拉到他的房間，給他個電腦屏幕和鍵盤。 我還想把成本控制在1000塊錢以内來著 原有機件介紹服務器是一臺大致如下配置的服務器 配件 型號 已用 主板 B75 / SATA口 2*3.0+4*2.0 已用3 PCI-E插槽 2条PCI-E*16 已用一條用於網卡 CPU i5-3330 虛擬機1+1+4+4+2 RAM 8G*2 DDR3 1600 已用512M*3+1.5G+2G=5G 可以看到CPU部分略微吃緊，而RAM依然有機會分配8G給虛擬機使用，PCI-E插槽可以容納一張獨立顯卡，硬盤也可以插多一張SSD。 找時間把各種吃CPU的服務搬出伺服器為上策。 需要添置的硬件由於我是要給現有的伺服器增加一個Win10，並給他加上顯卡與硬盤等等外設，還要讓他可以在遠處傳輸，於是這需要以下配件。 配件 名稱 價格 顯卡 RX550 2G半高顯卡 333港幣 硬盤 240G臺電SSD 210港幣 USB延長綫 / 142港幣 HDMI延長綫 / 128港幣 總價 814港幣 總而言之價格是控制在了1000港幣以内，算是完成目标。 等到我有空，買完所有需要的配件就開搞]]></content>
      <categories>
        <category>技術相關</category>
      </categories>
      <tags>
        <tag>Proxmox</tag>
        <tag>直通</tag>
      </tags>
  </entry>
</search>
